<script type="text/html" data-template-name="buyer config">

<style>
.device-available {
    color: #4CAF50 !important;
    font-weight: bold;
}

.device-in-use {
    color: #f44336 !important;
    font-style: italic;
}

#node-input-loadDevice option:disabled {
    color: #999 !important;
    background-color: #f5f5f5 !important;
}

#node-input-loadDevice option:disabled:hover {
    background-color: #f5f5f5 !important;
}
</style>

<div class="neuron-buyer-config">

    <div class="form-row">
        <label for="node-input-name"> <span>Name</span></label>
        <input type="text" id="node-input-name" placeholder="Node name">
    </div>

    <div class="form-row">
        <label for="node-input-smartContract"><i class="fa fa-file-contract"></i> <span>Smart Contract</span></label>
        <select id="node-input-smartContract" style="width: 70%;">
            <option value="jetvision" selected>JETVISION DEMO</option>
            <option value="chat">P2P CHAT DEMO</option>
            <option value="challenges">DEVELOPER OPEN CHALLENGES</option>
           <!-- <option value="Weather">Weather</option> -->

        </select>
    </div>
    <div class="form-row" id="device-reinstatement-section" style="border-top: 1px solid #555; padding-top: 15px; margin-top: 15px; display: none;">
        <label for="node-input-loadDevice">Reinstantiate Device</span></label>
         <select id="node-input-loadDevice" style="width: 70%;">
            <option value="">Create new device configuration</option>
        </select>
        <button type="button" id="refresh-devices-btn" class="red-ui-button" title="Refresh device list">
            <i class="fa fa-refresh"></i>
        </button>
        <div style="margin-top: 5px; font-size: 12px; color: #888;">
            <i>Select an existing device to reinstantiate its configuration</i>
        </div>
        <input type="hidden" id="node-input-originalDeviceFilename" />
    </div>

    <!-- Device Reinstatement Section -->
    

    <div class="form-row">
        <label for="node-input-deviceType"><span>Device Type</span></label>
        <input type="text" id="node-input-deviceType" placeholder="Enter Device Type e.g Cloud, Edge">
    </div>
    
    <!-- Hidden field to store loaded device filename -->
    <input type="hidden" id="node-input-loadedDeviceFilename" />
    <!-- Replace the existing seller selection section with this inline version -->
    <span style="margin-top:20px;"><i>Sellers I want data from (Should be in selected Smart Contract above )</i></span>
    <div class="form-row">
        <div style="margin-top: 10px;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="evm-address-input" placeholder="Enter EVM address (0x...)" 
                       style="flex: 1; font-family: monospace; font-size: 12px;">
                <button type="button" id="add-device-btn" class="red-ui-button">
                    <i class="fa fa-plus"></i> Add Seller
                </button>
            </div>
            
            <div id="devices-table-container" style="margin-top: 10px; border: 1px solid #555; border-radius: 5px; padding: 10px;">
                <table id="devices-table" style="width: 100%; border-collapse: collapse; display: none;">
                    <thead>
                        <tr style="background-color: #2d2d2d; color: white;">
                            <th style="padding: 8px; border: 1px solid #555; text-align: left;">EVM Address</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: center; width: 120px;">Shared Account</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: center; width: 100px;">Status</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: center; width: 100px;">Last Seen</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: center; width: 60px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="devices-table-body">
                    </tbody>
                </table>
                
                <div id="no-devices-message" style="text-align: center; color: #888; padding: 20px; font-style: italic;">
                    No devices added yet. Enter an EVM address above to add a device.
                </div>
                
                <div id="devices-summary" style="margin-top: 10px; font-size: 12px; color: #666;">
                    <span id="device-count">0</span> device(s) configured
                </div>
            </div>
        </div>
        
        <!-- Keep the hidden input for data storage -->
        <input type="hidden" id="node-input-sellerEvmAddress" />
    </div>
    <div class="form-row">
        <label for="node-input-description"> <span>Description</span></label>
        <input type="text" id="node-input-description" placeholder="Description (optional)">
    </div>
    <i style="color: #ffc107;">Click <span style="color: red">Done</span> then click <span style="color: red">Deploy</span> to create/update device</i>
    
    <div id="no-device-message" style="margin: 15px 0; padding: 10px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; color: #6c757d; font-style: italic;">
        <i class="fa fa-info-circle" style="margin-right: 5px;"></i>
        Runtime information will appear here after the device is created (after first deployment).
    </div>
    
    <!-- Separator line between configuration and runtime information -->
    <hr style="margin: 15px 0; border: none; border-top: 1px solid #ccc;">
    
    <!-- Runtime Information Section -->
    <div id="runtime-information-section" style="display: none;">
        <h4 style="margin: 10px 0; color:#28a745;">Runtime Information</h4>

        <div class="form-row">
            <label for="node-input-evmAddress"><span>EVM Address</span></label>
            <div style="display: flex; align-items: center; gap: 5px; width: 75%;">
                <input type="text" id="node-input-evmAddress" placeholder="EVM address will appear here after initialization" readonly style="flex: 1;">
                <button type="button" id="copy-evm-address-btn" class="red-ui-button" style="padding: 4px 8px; font-size: 12px; min-width: auto;" title="Copy EVM Address">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                </button>
            </div>
        </div>

        <div class="form-row">
            <label for="node-input-balance"><span>Balance</span></label>
            <input type="text" id="node-input-balance" placeholder="Account balance will appear here after initialization" readonly>
            <small><a href="https://portal.hedera.com/faucet" target="_blank" style="color:#4d90fe; text-decoration: underline;"> Top up account</a></small>
        </div>

        <div class="form-row">
            <label for="node-input-publicKey"><span>Public Key</span></label>
            <input type="text" id="node-input-publicKey" placeholder="Public key will appear here after initialization" readonly>
        </div>

        <!-- Add these three new topic fields -->
        <div class="form-row">
            <label for="node-input-stdInTopic"><span>StdIn Topic</span></label>
            <input type="text" id="node-input-stdInTopic" placeholder="StdIn topic will appear here after initialization" readonly>
        </div>

        <div class="form-row">
            <label for="node-input-stdOutTopic"><span>StdOut Topic</span></label>
            <input type="text" id="node-input-stdOutTopic" placeholder="StdOut topic will appear here after initialization" readonly>
        </div>

        <div class="form-row">
            <label for="node-input-stdErrTopic"><span>StdErr Topic</span></label>
            <input type="text" id="node-input-stdErrTopic" placeholder="StdErr topic will appear here after initialization" readonly>
        </div>

        <div class="form-row">
            <label for="node-input-heartbeat"><span>Reachability</span></label>
            <input type="text" id="node-input-heartbeat" placeholder="Reachability will appear here after initialization" readonly>
            <button type="button" id="refresh-heartbeat-btn" class="red-ui-button" style="margin-left: 5px; padding: 4px 8px; font-size: 12px; min-width: auto;" title="Refresh Reachability">
                <i class="fa fa-refresh"></i>
            </button>
        </div>

        <div class="form-row">
            <label for="node-input-reachability"><span>STDIN</span></label>
            <input type="text" id="node-input-reachability" placeholder="Last received message will appear here after initialization" readonly>
            <button type="button" id="refresh-reachability-btn" class="red-ui-button" style="margin-left: 5px; padding: 4px 8px; font-size: 12px; min-width: auto;" title="Refresh STDIN">
                <i class="fa fa-refresh"></i>
            </button>
        </div>
    </div>

    <!-- Connection Status Section - moved to bottom -->
   <!-- <div class="form-row">
        <label><span>Connection Status</span></label>
        <div id="connection-status-indicator" style="display: inline-block; margin-left: 10px;">
            <span id="status-dot" style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #ccc; margin-right: 5px;"></span>
            <span id="status-text" style="color: white;">Unknown</span>
        </div>
        <button type="button" id="refresh-connections-btn" class="red-ui-button" style="margin-left: 10px;">
            <i class="fa fa-refresh"></i> Refresh
        </button>
    </div>-->
    
    <!--<div class="form-row">
        <label><span>Connected Peers</span></label>
        <div id="connected-peers-container" style="margin-top: 10px;">
            <div id="peers-loading" style="text-align: center; color: black; padding: 20px;">
                <i class="fa fa-spinner fa-spin"></i> Loading connection status...
            </div>
            <div id="peers-content" style="display: none;">
                <div id="peers-summary" style="margin-bottom: 10px; font-weight: bold; color: white;">
                    <span id="connected-count">0</span> connected, <span id="total-count">0</span> total peers
                </div>
                <div id="peers-list" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background-color: #f9f9f9;">
                    <div id="no-peers-message" style="text-align: center; color: black; font-style: italic;">
                        No peers connected
                    </div>
                    <table id="peers-table" style="width: 100%; display: none; color: black;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 5px; border-bottom: 1px solid #ddd; color: black;">Public Key</th>
                                <th style="text-align: center; padding: 5px; border-bottom: 1px solid #ddd; color: black;">Status</th>
                                <th style="text-align: center; padding: 5px; border-bottom: 1px solid #ddd; color: black;">Last Update</th>
                            </tr>
                        </thead>
                        <tbody id="peers-table-body">
                        </tbody>
                    </table>
                </div>
                <div id="last-update-info" style="margin-top: 5px; font-size: 12px; color: black;">
                    Last updated: <span id="last-update-time">Never</span>
                </div>
            </div>
        </div>
    </div>-->


    <!-- The seller-modal div is no longer needed -->
</div>
</script>



<script type="text/javascript">
    // Move shared variables/functions outside the IIFE

    // Global helper function to ensure EVM address has '0x' prefix
    window.formatEvmAddress = function(evmAddress) {
        if (!evmAddress || evmAddress.trim() === '') {
            return evmAddress;
        }
        
        const trimmedAddress = evmAddress.trim();
        if (trimmedAddress.startsWith('0x')) {
            // Remove any spaces after '0x' and return the clean address
            return '0x' + trimmedAddress.substring(2).trim();
        } else {
            return '0x' + trimmedAddress;
        }
    };

    RED.nodes.registerType('buyer config', {
        category: 'Neuron',
        color: '#9799b2',
        editDialogSize: {
            width: '600px',
            height: 'auto'
        },
        defaults: {
            name: { value: "Buyer" },
            sellerEvmAddress: { value: [] },
            sellerDevices: { value: [] },
            smartContract: { value: "jetvision" }, // Ensure this has a default value
            deviceType: { value: null, required: true },
            description: { value: "" },
            evmAddress: { value: "" },
            balance: { value: "" },
            publicKey: { value: "" },
            // Add these three new fields
            stdInTopic: { value: "" },
            stdOutTopic: { value: "" },
            stdErrTopic: { value: "" },
            // Heartbeat field
            heartbeat: { value: "" },
            // Reachability field
            reachability: { value: "" },
            // Device reinstatement field
            loadedDeviceFilename: { value: "" },
            originalDeviceFilename: { value: "" }
        },
        inputs: 0,
        outputs: 1,
        icon: "serial.svg",
        label: function () {
            return this.name || "Neuron Buyer";
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : "";
        },
        oneditprepare: function () {
            const node = this;
            node.devicesList = []; // Store device objects

            // Timer for updates
            let autoUpdateInterval = null;

            // Initialize loadedDeviceFilename from hidden field if it exists
            // This ensures auto-refresh functions respect previously loaded devices
            const loadedFilename = $('#node-input-loadedDeviceFilename').val();
            if (loadedFilename && loadedFilename.trim() !== '') {
                node.loadedDeviceFilename = loadedFilename;
                console.log(`[BUYER INIT] Restored loaded device filename: ${node.loadedDeviceFilename}`);
            }
            
            // Initialize originalDeviceFilename from hidden field if it exists
            const originalFilename = $('#node-input-originalDeviceFilename').val();
            if (originalFilename && originalFilename.trim() !== '') {
                node.originalDeviceFilename = originalFilename;
                console.log(`[BUYER INIT] Restored original device filename: ${node.originalDeviceFilename}`);
            }

            // Function to make configuration fields readonly after deployment
            async function makeFieldsReadonlyIfDeployed() {
                if (node.id) {
                    try {
                        const response = await fetch(`/buyer/device-exists/${node.id}`);
                        const data = await response.json();
                        
                        if (data.success && data.exists) {
                            // Node has been deployed, make fields readonly (except name)
                            const readonlyInputFields = [
                                'node-input-deviceType',
                                'node-input-description'
                            ];
                            
                            const readonlySelectFields = [
                                'node-input-smartContract'
                            ];
                            
                            // Make input fields readonly
                            readonlyInputFields.forEach(fieldId => {
                                const field = $(`#${fieldId}`);
                                if (field.length) {
                                    field.prop('readonly', true);
                                    field.css('background-color', 'var(--red-ui-form-input-background-disabled)');
                                    field.css('color', 'var(--red-ui-form-text-color-disabled)');
                                    field.attr('title', 'This field cannot be changed after deployment');
                                }
                            });
                            
                            // Make select fields disabled
                            readonlySelectFields.forEach(fieldId => {
                                const field = $(`#${fieldId}`);
                                if (field.length) {
                                    field.prop('disabled', true);
                                    field.css('background-color', 'var(--red-ui-form-input-background-disabled)');
                                    field.css('color', 'var(--red-ui-form-text-color-disabled)');
                                    field.attr('title', 'This field cannot be changed after deployment');
                                }
                            });
                            
                            // Hide device configuration dropdown for deployed nodes
                            $('#device-reinstatement-section').hide();
                            
                            console.log(`[BUYER READONLY] Made configuration fields readonly and hid device dropdown for deployed node: ${node.id}`);
                        } else {
                            // Node not deployed, ensure fields are editable
                            const editableInputFields = [
                                'node-input-deviceType',
                                'node-input-description'
                            ];
                            
                            const editableSelectFields = [
                                'node-input-smartContract'
                            ];
                            
                            // Make input fields editable
                            editableInputFields.forEach(fieldId => {
                                const field = $(`#${fieldId}`);
                                if (field.length) {
                                    field.prop('readonly', false);
                                    field.css('background-color', '');
                                    field.css('color', '');
                                    field.removeAttr('title');
                                }
                            });
                            
                            // Make select fields enabled
                            editableSelectFields.forEach(fieldId => {
                                const field = $(`#${fieldId}`);
                                if (field.length) {
                                    field.prop('disabled', false);
                                    field.css('background-color', '');
                                    field.css('color', '');
                                    field.removeAttr('title');
                                }
                            });
                            
                            // Show device configuration dropdown for new nodes
                            // Note: The dropdown will be shown/hidden based on available configurations in loadEligibleDevices()
                            
                            console.log(`[BUYER READONLY] Made configuration fields editable for new node: ${node.id}`);
                        }
                    } catch (error) {
                        console.error(`[BUYER READONLY] Error checking deployment status:`, error);
                    }
                }
            }

            // Cleanup function
            this._cleanup = function () {
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                    autoUpdateInterval = null;
                    console.log('[DEBUG] Auto-update interval cleared');
                }
            };

            // Helper function to ensure EVM address has '0x' prefix (defined locally for compatibility)
            const formatEvmAddress = window.formatEvmAddress;

            // ===== DEVICE REINSTATEMENT FUNCTIONALITY =====

            // Load all devices with status into dropdown
            async function loadEligibleDevices() {
                try {
                    const response = await fetch('/buyer/devices/eligible');
                    const data = await response.json();

                    const dropdown = $('#node-input-loadDevice');
                    const currentValue = dropdown.val();
                    const deviceSection = $('#device-reinstatement-section');

                    // Clear existing options except the first one
                    dropdown.find('option:not(:first)').remove();

                    if (data.success && data.devices.length > 0) {
                        data.devices.forEach(device => {
                            const formattedAddress = formatEvmAddress(device.evmAddress);
                            const truncatedAddress = formattedAddress.substring(0, 10) + '...';
                            
                            let optionText = `${device.deviceName} (${truncatedAddress})`;
                            let optionClass = '';
                            
                            if (!device.available) {
                                optionText += ` - In use by "${device.usedBy}"`;
                                optionClass = 'device-in-use';
                            } else {
                                optionText += ' ✓ Available';
                                optionClass = 'device-available';
                            }
                            
                            const option = $(`<option value="${device.filename}" class="${optionClass}">${optionText}</option>`);
                            
                            // Disable unavailable options
                            if (!device.available) {
                                option.prop('disabled', true);
                            }
                            
                            dropdown.append(option);
                        });
                        
                        // Show the device section only if there are available configurations
                        if (data.availableCount > 0) {
                            deviceSection.show();
                            console.log(`[BUYER DEVICE LOAD] Loaded ${data.devices.length} devices (${data.availableCount} available, ${data.devices.length - data.availableCount} in use) - showing dropdown`);
                        } else {
                            deviceSection.hide();
                            console.log(`[BUYER DEVICE LOAD] Loaded ${data.devices.length} devices but none are available - hiding dropdown`);
                        }
                    } else {
                        // Hide the device section if no devices
                        deviceSection.hide();
                        console.log('[BUYER DEVICE LOAD] No devices found');
                    }

                    // Restore previous selection if it still exists, or pre-select current configuration
                    let selectionToRestore = currentValue;
                    
                    // If no current selection but we have an original device filename, use that
                    if (!selectionToRestore && node.originalDeviceFilename && node.originalDeviceFilename.trim() !== '') {
                        selectionToRestore = node.originalDeviceFilename;
                        console.log(`[BUYER DEVICE LOAD] Pre-selecting original device configuration: ${selectionToRestore}`);
                    }
                    
                    if (selectionToRestore && dropdown.find(`option[value="${selectionToRestore}"]`).length > 0) {
                        dropdown.val(selectionToRestore);
                        console.log(`[BUYER DEVICE LOAD] Restored device selection: ${selectionToRestore}`);
                    }

                } catch (error) {
                    console.error('[BUYER DEVICE LOAD] Error loading devices:', error);
                    // Hide section on error
                    $('#device-reinstatement-section').hide();
                }
            }

            // Load device configuration when selected
            async function loadDeviceConfiguration(filename) {
                if (!filename) {
                    console.log('[BUYER DEVICE LOAD] No device selected, keeping current configuration');
                    return;
                }

                try {
                    const response = await fetch(`/device/${filename}`);
                    const data = await response.json();

                    if (data.success && data.data) {
                        const deviceData = data.data;
                        console.log('[BUYER DEVICE LOAD] Loading device configuration:', filename);

                        // Pre-fill form fields with loaded device data
                        if (deviceData.deviceType) $('#node-input-deviceType').val(deviceData.deviceType);

                        // ===== POPULATE RUNTIME INFORMATION =====

                        // Show the runtime information section and hide the "no device" message
                        $('#runtime-information-section').show();
                        $('#no-device-message').hide();

                        // Populate EVM Address
                        if (deviceData.evmAddress) {
                            $('#node-input-evmAddress').val(formatEvmAddress(deviceData.evmAddress));
                        }

                        // Populate Public Key (fetch fresh from EVM address)
                        if (deviceData.evmAddress) {
                            try {
                                const publicKeyResponse = await fetch(`/buyer/evm-to-publickey/${deviceData.evmAddress}`);
                                const publicKeyData = await publicKeyResponse.json();

                                if (publicKeyData.success && publicKeyData.publicKey) {
                                    $('#node-input-publicKey').val(publicKeyData.publicKey);
                                    console.log('[BUYER DEVICE LOAD] Fetched fresh public key from EVM address');
                                } else if (deviceData.publicKey) {
                                    // Fallback to stored public key if fetch fails
                                    $('#node-input-publicKey').val(deviceData.publicKey);
                                    console.log('[BUYER DEVICE LOAD] Using stored public key (fetch failed)');
                                }
                            } catch (error) {
                                console.error('[BUYER DEVICE LOAD] Error fetching public key:', error);
                                if (deviceData.publicKey) {
                                    $('#node-input-publicKey').val(deviceData.publicKey);
                                }
                            }
                        } else if (deviceData.publicKey) {
                            $('#node-input-publicKey').val(deviceData.publicKey);
                        }

                        // Populate Topics from topics array
                        if (deviceData.topics && Array.isArray(deviceData.topics)) {
                            // Map topics array to individual fields (typically [stdIn, stdOut, stdErr])
                            if (deviceData.topics.length >= 3) {
                                $('#node-input-stdInTopic').val(deviceData.topics[0] || '');
                                $('#node-input-stdOutTopic').val(deviceData.topics[1] || '');
                                $('#node-input-stdErrTopic').val(deviceData.topics[2] || '');
                            } else if (deviceData.topics.length >= 1) {
                                // If only one topic, assume it's stdOut
                                $('#node-input-stdOutTopic').val(deviceData.topics[0]);
                            }
                        }

                        // Populate individual topic fields if they exist
                        if (deviceData.stdInTopic) $('#node-input-stdInTopic').val(deviceData.stdInTopic);
                        if (deviceData.stdOutTopic) $('#node-input-stdOutTopic').val(deviceData.stdOutTopic);
                        if (deviceData.stdErrTopic) $('#node-input-stdErrTopic').val(deviceData.stdErrTopic);

                        // Fetch and populate balance using accountId from device data
                        if (deviceData.accountId) {
                            try {
                                const balanceResponse = await fetch(`/device/balance/by-account/${deviceData.accountId}`);
                                const balanceData = await balanceResponse.json();

                                if (balanceData.success && balanceData.balance) {
                                    $('#node-input-balance').val(`${balanceData.balance} ${balanceData.unit}`);
                                    console.log('[BUYER DEVICE LOAD] Fetched current balance:', balanceData.balance, balanceData.unit);
                                } else {
                                    $('#node-input-balance').val('Balance not available');
                                    console.log('[BUYER DEVICE LOAD] Balance fetch failed:', balanceData.error);
                                }
                            } catch (error) {
                                console.error('[BUYER DEVICE LOAD] Error fetching balance:', error);
                                $('#node-input-balance').val('Balance fetch error');
                            }
                        } else if (deviceData.evmAddress) {
                            // Fallback to EVM address method if accountId is not available
                            try {
                                const balanceResponse = await fetch(`/device/balance/${deviceData.evmAddress}`);
                                const balanceData = await balanceResponse.json();

                                if (balanceData.success && balanceData.balance) {
                                    $('#node-input-balance').val(`${balanceData.balance} ${balanceData.unit}`);
                                    console.log('[BUYER DEVICE LOAD] Fetched current balance via EVM:', balanceData.balance, balanceData.unit);
                                } else {
                                    $('#node-input-balance').val('Balance not available');
                                    console.log('[BUYER DEVICE LOAD] Balance fetch failed:', balanceData.error);
                                }
                            } catch (error) {
                                console.error('[BUYER DEVICE LOAD] Error fetching balance:', error);
                                $('#node-input-balance').val('Balance fetch error');
                            }
                        }

                        // Fetch and populate heartbeat
                        if (node.id) {
                            try {
                                const heartbeatResponse = await fetch(`/buyer/heartbeat/${node.id}`);
                                const heartbeatData = await heartbeatResponse.json();

                                if (heartbeatData.success && heartbeatData.heartbeat) {
                                    const heartbeat = heartbeatData.heartbeat;
                                    if (heartbeat.lastSeenFormatted) {
                                        $('#node-input-heartbeat').val(heartbeat.lastSeenFormatted);
                                        console.log('[BUYER DEVICE LOAD] Fetched heartbeat:', heartbeat.lastSeenFormatted);
                                    } else {
                                        $('#node-input-heartbeat').val('Never');
                                        console.log('[BUYER DEVICE LOAD] No heartbeat data available');
                                    }
                                } else {
                                    $('#node-input-heartbeat').val('Heartbeat not available');
                                    console.log('[BUYER DEVICE LOAD] Heartbeat fetch failed:', heartbeatData.error);
                                }
                            } catch (error) {
                                console.error('[BUYER DEVICE LOAD] Error fetching heartbeat:', error);
                                $('#node-input-heartbeat').val('Heartbeat fetch error');
                            }
                        }

                        // Update seller devices list if present
                        if (deviceData.sellerEvmAddress) {
                            try {
                                const sellerAddresses = JSON.parse(deviceData.sellerEvmAddress);
                                if (Array.isArray(sellerAddresses) && sellerAddresses.length > 0) {
                                    // Update the config field with the loaded seller addresses
                                    node.sellerEvmAddress = deviceData.sellerEvmAddress;
                                    
                                    node.devicesList = sellerAddresses.map(addr => ({
                                        evmAddress: addr,
                                        deviceName: 'Loaded Device',
                                        deviceType: 'Loaded',
                                        stdInTopic: 'Unknown',
                                        stdOutTopic: 'Unknown',
                                        stdErrTopic: 'Unknown',
                                        status: 'Unknown',
                                        lastSeen: 'Unknown'
                                    }));
                                    updateDevicesTable();
                                    console.log('[BUYER DEVICE LOAD] Loaded seller addresses:', sellerAddresses);
                                }
                            } catch (parseError) {
                                console.error('[BUYER DEVICE LOAD] Error parsing seller addresses:', parseError);
                            }
                        }

                        // Store the loaded device filename for later use
                        node.loadedDeviceFilename = filename;
                        node.originalDeviceFilename = filename;
                        $('#node-input-loadedDeviceFilename').val(filename);
                        $('#node-input-originalDeviceFilename').val(filename);

                        console.log('[BUYER DEVICE LOAD] Device configuration and runtime information loaded successfully');
                    } else {
                        console.error('[BUYER DEVICE LOAD] Failed to load device data:', data.error);
                    }

                } catch (error) {
                    console.error('[BUYER DEVICE LOAD] Error loading device configuration:', error);
                }
            }

            // Event handlers for device loading
            $('#refresh-devices-btn').on('click', function () {
                console.log('[BUYER DEVICE LOAD] Refreshing device list...');
                loadEligibleDevices();
            });

            // Event handler for heartbeat refresh
            $('#refresh-heartbeat-btn').on('click', async function () {
                if (!node.id) {
                    console.log('[BUYER HEARTBEAT] No node ID available');
                    return;
                }

                const btn = $(this);
                const originalHtml = btn.html();
                
                // Show loading state
                btn.html('<i class="fa fa-spinner fa-spin"></i>');
                btn.prop('disabled', true);

                try {
                    const heartbeatResponse = await fetch(`/buyer/heartbeat/${node.id}`);
                    const heartbeatData = await heartbeatResponse.json();

                    if (heartbeatData.success && heartbeatData.heartbeat) {
                        const heartbeat = heartbeatData.heartbeat;
                        if (heartbeat.lastSeenFormatted) {
                            // Format: "natReachability - last stdout timestamp" or just "last stdout timestamp"
                            let displayText = '';
                            if (heartbeat.natReachability !== null && heartbeat.natReachability !== undefined) {
                                displayText = `${heartbeat.natReachability} - last stdout ${heartbeat.lastSeenFormatted}`;
                            } else {
                                displayText = `last stdout ${heartbeat.lastSeenFormatted}`;
                            }
                            $('#node-input-heartbeat').val(displayText);
                            console.log('[BUYER HEARTBEAT] Refreshed heartbeat:', displayText);
                        } else {
                            $('#node-input-heartbeat').val('Never');
                            console.log('[BUYER HEARTBEAT] No heartbeat data available');
                        }
                    } else {
                        $('#node-input-heartbeat').val('Heartbeat not available');
                        console.log('[BUYER HEARTBEAT] Heartbeat fetch failed:', heartbeatData.error);
                    }
                } catch (error) {
                    console.error('[BUYER HEARTBEAT] Error refreshing heartbeat:', error);
                    $('#node-input-heartbeat').val('Heartbeat fetch error');
                } finally {
                    // Restore button
                    btn.html(originalHtml);
                    btn.prop('disabled', false);
                }
            });

            // Event handler for reachability refresh
            $('#refresh-reachability-btn').on('click', async function () {
                if (!node.id) {
                    console.log('[BUYER REACHABILITY] No node ID available');
                    return;
                }

                const btn = $(this);
                const originalHtml = btn.html();
                
                // Show loading state
                btn.html('<i class="fa fa-spinner fa-spin"></i>');
                btn.prop('disabled', true);

                try {
                    const reachabilityResponse = await fetch(`/buyer/reachability/${node.id}`);
                    const reachabilityData = await reachabilityResponse.json();

                    if (reachabilityData.success && reachabilityData.reachability) {
                        const reachability = reachabilityData.reachability;
                        if (reachability.lastSeenFormatted && reachability.messageType) {
                            // Format: "natReachability - timestamp (messageType)"
                            let displayText = '';
                            if (reachability.natReachability !== null && reachability.natReachability !== undefined) {
                                displayText = `${reachability.natReachability} - ${reachability.lastSeenFormatted} (${reachability.messageType})`;
                            } else {
                                displayText = `${reachability.lastSeenFormatted} (${reachability.messageType})`;
                            }
                            $('#node-input-reachability').val(displayText);
                            console.log('[BUYER REACHABILITY] Refreshed reachability:', displayText);
                        } else if (reachability.lastSeenFormatted) {
                            $('#node-input-reachability').val(reachability.lastSeenFormatted);
                            console.log('[BUYER REACHABILITY] Refreshed reachability:', reachability.lastSeenFormatted);
                        } else {
                            $('#node-input-reachability').val('Never');
                            console.log('[BUYER REACHABILITY] No reachability data available');
                        }
                    } else {
                        $('#node-input-reachability').val('Reachability not available');
                        console.log('[BUYER REACHABILITY] Reachability fetch failed:', reachabilityData.error);
                    }
                } catch (error) {
                    console.error('[BUYER REACHABILITY] Error refreshing reachability:', error);
                    $('#node-input-reachability').val('Reachability fetch error');
                } finally {
                    // Restore button
                    btn.html(originalHtml);
                    btn.prop('disabled', false);
                }
            });

            $('#node-input-loadDevice').on('change', function () {
                const selectedFilename = $(this).val();
                console.log('[BUYER DEVICE LOAD] Device selection changed:', selectedFilename);
                loadDeviceConfiguration(selectedFilename);
            });

            // Initialize device dropdown on dialog open
            loadEligibleDevices();

            // Copy EVM Address functionality
            $('#copy-evm-address-btn').on('click', function() {
                const evmAddress = $('#node-input-evmAddress').val();
                if (evmAddress && evmAddress.trim() !== '' && evmAddress !== 'New node' && evmAddress !== 'Not initialized yet' && evmAddress !== 'EVM address not intialised') {
                    // Use the modern Clipboard API if available
                    if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard.writeText(evmAddress).then(function() {
                            // Show success feedback
                            const originalHTML = $(this).html();
                            $(this).html('<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20,6 9,17 4,12"></polyline></svg>');
                            setTimeout(() => {
                                $(this).html(originalHTML);
                            }, 1000);
                        }.bind(this)).catch(function(err) {
                            console.error('Failed to copy EVM address:', err);
                            // Fallback to manual copy
                            copyToClipboardFallback(evmAddress, this);
                        });
                    } else {
                        // Fallback for older browsers or non-secure contexts
                        copyToClipboardFallback(evmAddress, this);
                    }
                } else {
                    // Show error feedback
                    const originalHTML = $(this).html();
                    $(this).html('<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>');
                    setTimeout(() => {
                        $(this).html(originalHTML);
                    }, 1000);
                }
            });

            // Fallback copy function for older browsers
            function copyToClipboardFallback(text, button) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        // Show success feedback
                        const originalHTML = $(button).html();
                        $(button).html('<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20,6 9,17 4,12"></polyline></svg>');
                        setTimeout(() => {
                            $(button).html(originalHTML);
                        }, 1000);
                    } else {
                        throw new Error('Copy command failed');
                    }
                } catch (err) {
                    console.error('Failed to copy EVM address:', err);
                    // Show error feedback
                    const originalHTML = $(button).html();
                    $(button).html('<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>');
                    setTimeout(() => {
                        $(button).html(originalHTML);
                    }, 1000);
                } finally {
                    document.body.removeChild(textArea);
                }
            }

            console.log('[SCOPE TEST] node defined at start:', typeof node);

            // Initialize devices from existing configuration
            function initializeDevices() {
                console.log('[SCOPE TEST] node in initializeDevices:', typeof node);

                let storedDevices = node.sellerDevices || node.sellerEvmAddress || [];
                node.devicesList = [];

                if (Array.isArray(storedDevices)) {
                    if (storedDevices.length > 0) {
                        if (typeof storedDevices[0] === 'string') {
                            node.devicesList = storedDevices.map(addr => ({
                                evmAddress: addr,
                                deviceName: 'Legacy Device',
                                deviceType: 'Unknown',
                                stdInTopic: 'Unknown',
                                stdOutTopic: 'Unknown',
                                stdErrTopic: 'Unknown'
                            }));
                        } else if (storedDevices[0] && storedDevices[0].evmAddress) {
                            node.devicesList = [...storedDevices];
                        }
                    }
                }

                updateDevicesTable();
                updateDevicesSummary();
            }

            // Update devices table display - WITH SIMPLE 1-SEC REPEAT
            function updateDevicesTable() {
                console.log('[DEBUG] updateDevicesTable called, node available:', typeof node);

                const tableBody = $('#devices-table-body');
                const table = $('#devices-table');
                const noDevicesMsg = $('#no-devices-message');

                tableBody.empty();

                if (node.devicesList.length === 0) {
                    table.hide();
                    noDevicesMsg.show();
                    // Clear any existing interval if no devices
                    if (autoUpdateInterval) {
                        clearInterval(autoUpdateInterval);
                        autoUpdateInterval = null;
                    }
                    return;
                }

                table.show();
                noDevicesMsg.hide();

                node.devicesList.forEach((device, index) => {
                    const row = $(`
                        <tr data-seller-evm="${device.evmAddress}">
                            <td style="padding: 8px; border: 1px solid #555; font-family: monospace; font-size: 11px; word-break: break-all;">
                                ${device.evmAddress}
                            </td>
                            <td id="shared-account-cell-${index}" class="buyer-shared-account-cell" style="padding: 8px; border: 1px solid #555; text-align: center; font-size: 11px;">
                                -
                            </td>
                            <td id="status-cell-${index}" style="padding: 8px; border: 1px solid #555; text-align: center; font-size: 11px;">
                                <i class="fa fa-spinner fa-spin" style="color: #888;"></i>
                            </td>
                            <td id="lastseen-cell-${index}" style="padding: 8px; border: 1px solid #555; text-align: center; font-size: 11px;">
                                <i class="fa fa-spinner fa-spin" style="color: #888;"></i>
                            </td>
                            <td style="padding: 8px; border: 1px solid #555; text-align: center;">
                                <button type="button" class="red-ui-button red-ui-button-small remove-device-btn" 
                                        data-index="${index}" style="padding: 2px 6px;">
                                    <i class="fa fa-trash"></i>
                                </button>
                                        </td>
                                    </tr>
                                `);
                    tableBody.append(row);
                });

                // Attach remove button handlers
                $('.remove-device-btn').click(function () {
                    const index = parseInt($(this).data('index'));
                    removeDevice(index);
                });

                console.log('[DEBUG] Table updated, starting 1-second repeat calls');

                // Start simple 1-second repeat if node.id is available
                if (node.id && node.devicesList.length > 0) {
                    startSimpleRepeats();
                }
            }

            // Simple function to start 1-second repeats - INSIDE oneditprepare
            function startSimpleRepeats() {
                // Clear any existing interval
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                }


                // Do initial call
                autoCheckAllDevices();

                // Set up simple interval for every 5 second
                autoUpdateInterval = setInterval(() => {
                    if (node.devicesList.length > 0) {
                        autoCheckAllDevices();
                    } else {
                        // No devices, clear interval
                        clearInterval(autoUpdateInterval);
                        autoUpdateInterval = null;
                    }
                }, 30000); // 5 second
            }

            // Function to fetch shared account for a specific seller
            async function fetchSharedAccountForSeller(sellerEvmAddress, index) {
                const sharedAccountCell = $(`#shared-account-cell-${index}`);
                
                console.log(`[BUYER SHARED ACCOUNT] Cell selector: #shared-account-cell-${index}, found: ${sharedAccountCell.length}, current text: "${sharedAccountCell.text()}"`);
                
                // Check if already loaded (has a value other than '-')
                const currentValue = sharedAccountCell.text().trim();
                if (currentValue !== '-' && currentValue !== '' && currentValue.startsWith('0.0.')) {
                    console.log(`[BUYER SHARED ACCOUNT] Skipping fetch for seller ${sellerEvmAddress} - already loaded: ${currentValue}`);
                    return;
                }

                if (!node.id) {
                    console.warn('[BUYER SHARED ACCOUNT] No node ID available');
                    return;
                }

                try {
                    console.log(`[BUYER SHARED ACCOUNT] Fetching shared account for seller ${sellerEvmAddress}, index ${index}`);
                    const response = await fetch(`/buyer/shared-account/${node.id}/${sellerEvmAddress}`);
                    const data = await response.json();
                    
                    console.log(`[BUYER SHARED ACCOUNT] API response for seller ${sellerEvmAddress}:`, data);

                    if (data.success && data.sharedAccount) {
                        // Format as Hedera account: 0.0.{accountNumber}
                        const formattedAccount = `0.0.${data.sharedAccount}`;
                        sharedAccountCell.text(formattedAccount);
                        sharedAccountCell.attr('title', `Shared account: ${formattedAccount}`);
                        console.log(`[BUYER SHARED ACCOUNT] Set shared account for seller ${sellerEvmAddress}: ${formattedAccount}`);
                    } else {
                        sharedAccountCell.text('-');
                        sharedAccountCell.attr('title', data.message || 'No shared account found');
                        console.log(`[BUYER SHARED ACCOUNT] No shared account for seller ${sellerEvmAddress}`);
                    }
                } catch (error) {
                    console.error(`[BUYER SHARED ACCOUNT] Error fetching shared account for seller ${sellerEvmAddress}:`, error);
                    sharedAccountCell.text('-');
                    sharedAccountCell.attr('title', 'Error fetching shared account');
                }
            }

            // Auto-check function - INSIDE oneditprepare
            async function autoCheckAllDevices() {
                if (!node.id) {
                    return;
                }

                try {
                    // First check if the node is deployed (has a device file)
                    const existsResponse = await fetch(`/buyer/device-exists/${node.id}`);
                    if (!existsResponse.ok) {
                        // Node not deployed, show not initialized
                        for (let index = 0; index < node.devicesList.length; index++) {
                            $(`#status-cell-${index}`).html('<span style="color: #888;">Not deployed</span>');
                            $(`#lastseen-cell-${index}`).html('<span style="color: #888;">Not deployed</span>');
                        }
                        return;
                    }

                    const existsData = await existsResponse.json();
                    if (!existsData.success || !existsData.exists) {
                        // Device file doesn't exist, node not deployed
                        for (let index = 0; index < node.devicesList.length; index++) {
                            $(`#status-cell-${index}`).html('<span style="color: #888;">Not deployed</span>');
                            $(`#lastseen-cell-${index}`).html('<span style="color: #888;">Not deployed</span>');
                        }
                        return;
                    }

                    // Get connection status for this buyer node
                    const connectionResponse = await fetch(`/buyer/connection-status/${node.id}`);
                    if (!connectionResponse.ok) {
                        throw new Error(`Connection API returned ${connectionResponse.status}`);
                    }

                    const connectionData = await connectionResponse.json();

                    // Create a map of public keys to connection status
                    const statusMap = new Map();
                    if (connectionData.peers && Array.isArray(connectionData.peers)) {
                        connectionData.peers.forEach(peer => {
                            if (peer.publicKey) {
                                statusMap.set(peer.publicKey, peer.connectionStatus || 'No connection');
                            }
                        });
                    }

                    // Process each device
                    for (let index = 0; index < node.devicesList.length; index++) {
                        const device = node.devicesList[index];
                        checkDeviceStatusAuto(device, index, statusMap);
                        checkLastSeenAuto(device, index);
                    }

                } catch (error) {
                    console.error('[DEBUG] Error in autoCheckAllDevices:', error);
                    // Set all cells to error
                    for (let index = 0; index < node.devicesList.length; index++) {
                        $(`#status-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
                        $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
                    }
                }
            }

            // Auto status check function - INSIDE oneditprepare
            async function checkDeviceStatusAuto(device, index, statusMap) {
                const statusCell = $(`#status-cell-${index}`);

                try {
                    console.log('[DEBUG] Getting public key for device', index, ':', device.evmAddress);

                    // Get public key from EVM address
                    const evmResponse = await fetch(`/buyer/evm-to-publickey/${device.evmAddress}`);
                    const evmData = await evmResponse.json();

                    if (!evmData.success) {
                        console.log('[DEBUG] Failed to get public key for device', index);
                        statusCell.html('<span style="color: #dc3545;">Key Error</span>');
                        return;
                    }

                    const publicKey = evmData.publicKey;
                    const status = statusMap.get(publicKey) || 'No connection';

                    console.log('[DEBUG] Device', index, 'PublicKey:', publicKey, 'Status:', status);

                    // Color code the result
                    let color = '#dc3545'; // red for disconnected
                    if (status === 'connected') {
                        color = '#28a745'; // green
                        // Fetch shared account only for connected sellers
                        fetchSharedAccountForSeller(device.evmAddress, index);
                    } else if (status === 'connecting') {
                        color = '#ffc107'; // yellow
                    }

                    statusCell.html(`<span style="color: ${color};">${status}</span>`);

                } catch (error) {
                    console.error('[DEBUG] Error checking status for device', index, ':', error);
                    statusCell.html('<span style="color: #dc3545;">Error</span>');
                }
            }

            // Auto last seen check function - INSIDE oneditprepare
            async function checkLastSeenAuto(device, index) {
                const lastSeenCell = $(`#lastseen-cell-${index}`);

                try {
                    if (!device.stdOutTopic || device.stdOutTopic === 'Unknown') {
                        lastSeenCell.html('<span style="color: #888;">No Topic</span>');
                        return;
                    }

                    //console.log('[DEBUG] Getting last seen for device', index, 'topic:', device.stdOutTopic);

                    const normalizedTopic = normalizeTopicFormat(device.stdOutTopic);
                    const response = await fetch(`/buyer/last-seen/${normalizedTopic}`);
                    const data = await response.json();

                    if (data.success) {
                        if (data.lastSeen !== null) {
                            // Color code based on how recent the activity is
                            let color = '#888'; // default gray
                            if (data.lastSeen < 300) { // less than 5 minutes
                                color = '#28a745'; // green
                            } else if (data.lastSeen < 3600) { // less than 1 hour
                                color = '#ffc107'; // yellow
                            } else if (data.lastSeen < 86400) { // less than 1 day
                                color = '#fd7e14'; // orange
                            } else {
                                color = '#dc3545'; // red
                            }

                            lastSeenCell.html(`<span style="color: ${color};">${data.lastSeenFormatted}</span>`);
                        } else {
                            lastSeenCell.html('<span style="color: #888;">Never</span>');
                        }
                    } else {
                        // console.log('[DEBUG] Last seen API error for device', index, ':', data.error);
                        lastSeenCell.html('<span style="color: #dc3545;">API Error</span>');
                    }

                } catch (error) {
                    console.error('[DEBUG] Error checking last seen for device', index, ':', error);
                    lastSeenCell.html('<span style="color: #dc3545;">Error</span>');
                }
            }

            // Helper function for truncating topics - INSIDE oneditprepare
            function truncateTopic(topic) {
                if (!topic || topic.length <= 15) return topic;
                return topic.substring(0, 12) + '...';
            }

            // Validate EVM address format
            function isValidEvmAddress(address) {
                return /^0x[a-fA-F0-9]{40}$/.test(address);
            }

            // Add device functionality
            async function addDevice() {
                const evmInput = $('#evm-address-input');
                const addBtn = $('#add-device-btn');
                const evmAddress = evmInput.val().trim();

                // Validation
                if (!evmAddress) {
                    alert('Please enter an EVM address');
                    return;
                }

                if (!isValidEvmAddress(evmAddress)) {
                    alert('Please enter a valid EVM address (0x followed by 40 hex characters)');
                    return;
                }

                // Check for duplicates
                if (node.devicesList.some(d => d.evmAddress.toLowerCase() === evmAddress.toLowerCase())) {
                    alert('This device is already added');
                    return;
                }

                // Show loading state
                addBtn.prop('disabled', true);
                addBtn.html('<i class="fa fa-spinner fa-spin"></i> Fetching Device...');

                try {
                    // console.log(`[DEBUG] Fetching device for EVM: ${evmAddress}, Node ID: ${node.id}, Smart Contract: ${node.smartContract}`);

                    const response = await fetch(`/buyer/fetch-device-by-evm/${evmAddress}?nodeId=${node.id}&smartContract=${node.smartContract}`);
                    const data = await response.json();

                    // console.log(`[DEBUG] Response received:`, data);

                    if (data.success && data.device) {
                        // Add device to list
                        node.devicesList.push(data.device);
                        updateDevicesTable();
                        updateDevicesSummary();
                        evmInput.val(''); // Clear input

                        // console.log('[DEBUG] Device added successfully:', data.device);
                    } else {
                        // console.error('[DEBUG] Device fetch failed:', data);
                        alert(`Device not found: ${data.error || 'Unknown error'}`);
                    }

                } catch (error) {
                    // console.error('[DEBUG] Error fetching device:', error);
                    alert('Error fetching device information. Please check the console for details.');
                } finally {
                    // Restore button state
                    addBtn.prop('disabled', false);
                    addBtn.html('<i class="fa fa-plus"></i> Add Device');
                }
            }

            // Remove device functionality
            function removeDevice(index) {
                if (confirm('Are you sure you want to remove this device?')) {
                    node.devicesList.splice(index, 1);
                    updateDevicesTable();
                    updateDevicesSummary();
                }
            }

            // Update summary display
            function updateDevicesSummary() {
                $('#device-count').text(node.devicesList.length);

                // Update hidden input for storage
                const addressList = node.devicesList.map(d => d.evmAddress);
                $('#node-input-sellerEvmAddress').val(JSON.stringify(addressList));
            }

            // Event handlers
            $('#add-device-btn').click(addDevice);

            // Enter key in input field
            $('#evm-address-input').keypress(function (e) {
                if (e.which === 13) { // Enter key
                    addDevice();
                }
            });

            // Real-time validation styling
            $('#evm-address-input').on('input', function () {
                const value = $(this).val().trim();
                if (value && !isValidEvmAddress(value)) {
                    $(this).css('border-color', '#ff6b6b');
                } else {
                    $(this).css('border-color', '');
                }
            });

            // Initialize the interface
            initializeDevices();

            // Initialize connection status display
            if (node.id) {
                initializeBuyerConnectionStatus(node.id);
            }

            // Fetch and populate EVM address, publicKey, and topics if available
            function updateEvmAddressAndPublicKeyAndTopics() {
                // Skip auto-refresh if a device has been loaded - preserve loaded device data
                if (node.loadedDeviceFilename) {
                    console.log(`[BUYER AUTO-REFRESH] Skipping update - device loaded: ${node.loadedDeviceFilename}`);
                    return;
                }
                
                if (node.id) {
                    // First check if device file exists before making API calls
                    $.get(`/buyer/device-exists/${node.id}`)
                        .done(function (existsData) {
                            if (existsData.success && existsData.exists) {
                                // Device file exists, fetch device info
                                // console.log(`Fetching device info for node ID: ${node.id}`);
                                $.get(`/buyer/device-info/${node.id}`)
                                    .done(function (data) {
                                        // console.log(`Device info received for ${node.id}:`, data);

                                        // Handle EVM Address
                                        if (data.evmAddress) {
                                            $('#node-input-evmAddress').val(formatEvmAddress(data.evmAddress));
                                        } else {
                                            $('#node-input-evmAddress').val('Not initialized yet');
                                        }

                                        // Handle publicKey
                                        if (data.publicKey) {
                                            $('#node-input-publicKey').val(data.publicKey);
                                        } else {
                                            $('#node-input-publicKey').val('Not initialized yet');
                                        }

                                        // Handle Topics
                                        if (data.stdInTopic) {
                                            $('#node-input-stdInTopic').val(data.stdInTopic);
                                        } else {
                                            $('#node-input-stdInTopic').val('Not initialized yet');
                                        }

                                        if (data.stdOutTopic) {
                                            $('#node-input-stdOutTopic').val(data.stdOutTopic);
                                        } else {
                                            $('#node-input-stdOutTopic').val('Not initialized yet');
                                        }

                                        if (data.stdErrTopic) {
                                            $('#node-input-stdErrTopic').val(data.stdErrTopic);
                                        } else {
                                            $('#node-input-stdErrTopic').val('Not initialized yet');
                                        }
                                    })
                                    .fail(function (xhr, status, error) {
                                        // console.error(`Failed to fetch device info for ${node.id}:`, error);
                                        $('#node-input-evmAddress').val('EVM address not intialised');
                                        $('#node-input-publicKey').val('Public key not intialised');
                                        $('#node-input-stdInTopic').val('StdIn topic not intialised');
                                        $('#node-input-stdOutTopic').val('StdOut topic not intialised');
                                        $('#node-input-stdErrTopic').val('StdErr topic not intialised');
                                        $('#node-input-heartbeat').val('Heartbeat not available');
                                    });
                            } else {
                                // Device file doesn't exist, show new node messages
                                $('#node-input-evmAddress').val('New node - EVM address will be generated after deployment');
                                $('#node-input-publicKey').val('New node - Public key will be generated after deployment');
                                $('#node-input-stdInTopic').val('New node - StdIn topic will be generated after deployment');
                                $('#node-input-stdOutTopic').val('New node - StdOut topic will be generated after deployment');
                                $('#node-input-stdErrTopic').val('New node - StdErr topic will be generated after deployment');
                                $('#node-input-heartbeat').val('New node - Heartbeat will be available after deployment');
                            }
                        })
                        .fail(function () {
                            // If device-exists check fails, assume new node
                            $('#node-input-evmAddress').val('New node - EVM address will be generated after deployment');
                            $('#node-input-publicKey').val('New node - Public key will be generated after deployment');
                            $('#node-input-stdInTopic').val('New node - StdIn topic will be generated after deployment');
                            $('#node-input-stdOutTopic').val('New node - StdOut topic will be generated after deployment');
                            $('#node-input-stdErrTopic').val('New node - StdErr topic will be generated after deployment');
                            $('#node-input-heartbeat').val('New node - Heartbeat will be available after deployment');
                        });
                } else {
                    $('#node-input-evmAddress').val('New node - EVM address will be generated after deployment');
                    $('#node-input-publicKey').val('New node - Public key will be generated after deployment');
                    $('#node-input-stdInTopic').val('New node - StdIn topic will be generated after deployment');
                    $('#node-input-stdOutTopic').val('New node - StdOut topic will be generated after deployment');
                    $('#node-input-stdErrTopic').val('New node - StdErr topic will be generated after deployment');
                    $('#node-input-heartbeat').val('New node - Heartbeat will be available after deployment');
                    $('#node-input-reachability').val('New node - Reachability will be available after deployment');
                }
            }

            // Load heartbeat data
            async function loadHeartbeat() {
                if (!node.id) {
                    $('#node-input-heartbeat').val('No node ID available');
                    return;
                }

                try {
                    const heartbeatResponse = await fetch(`/buyer/heartbeat/${node.id}`);
                    const heartbeatData = await heartbeatResponse.json();

                    if (heartbeatData.success && heartbeatData.heartbeat) {
                        const heartbeat = heartbeatData.heartbeat;
                        if (heartbeat.lastSeenFormatted) {
                            // Format: "natReachability - last stdout timestamp" or just "last stdout timestamp"
                            let displayText = '';
                            if (heartbeat.natReachability !== null && heartbeat.natReachability !== undefined) {
                                displayText = `${heartbeat.natReachability} - last stdout ${heartbeat.lastSeenFormatted}`;
                            } else {
                                displayText = `last stdout ${heartbeat.lastSeenFormatted}`;
                            }
                            $('#node-input-heartbeat').val(displayText);
                            console.log('[BUYER HEARTBEAT] Loaded heartbeat:', displayText);
                        } else {
                            $('#node-input-heartbeat').val('Never');
                            console.log('[BUYER HEARTBEAT] No heartbeat data available');
                        }
                    } else {
                        $('#node-input-heartbeat').val('Heartbeat not available');
                        console.log('[BUYER HEARTBEAT] Heartbeat fetch failed:', heartbeatData.error);
                    }
                } catch (error) {
                    console.error('[BUYER HEARTBEAT] Error loading heartbeat:', error);
                    $('#node-input-heartbeat').val('Heartbeat fetch error');
                }
            }

            // Load reachability data
            async function loadReachability() {
                if (!node.id) {
                    $('#node-input-reachability').val('No node ID available');
                    return;
                }

                try {
                    const reachabilityResponse = await fetch(`/buyer/reachability/${node.id}`);
                    const reachabilityData = await reachabilityResponse.json();

                    if (reachabilityData.success && reachabilityData.reachability) {
                        const reachability = reachabilityData.reachability;
                        if (reachability.lastSeenFormatted && reachability.messageType) {
                            // Format: "natReachability - timestamp (messageType)"
                            let displayText = '';
                            if (reachability.natReachability !== null && reachability.natReachability !== undefined) {
                                displayText = `${reachability.natReachability} - ${reachability.lastSeenFormatted} (${reachability.messageType})`;
                            } else {
                                displayText = `${reachability.lastSeenFormatted} (${reachability.messageType})`;
                            }
                            $('#node-input-reachability').val(displayText);
                            console.log('[BUYER REACHABILITY] Loaded reachability:', displayText);
                        } else if (reachability.lastSeenFormatted) {
                            $('#node-input-reachability').val(reachability.lastSeenFormatted);
                            console.log('[BUYER REACHABILITY] Loaded reachability:', reachability.lastSeenFormatted);
                        } else {
                            $('#node-input-reachability').val('Never');
                            console.log('[BUYER REACHABILITY] No reachability data available');
                        }
                    } else {
                        $('#node-input-reachability').val('Reachability not available');
                        console.log('[BUYER REACHABILITY] Reachability fetch failed:', reachabilityData.error);
                    }
                } catch (error) {
                    console.error('[BUYER REACHABILITY] Error loading reachability:', error);
                    $('#node-input-reachability').val('Reachability fetch error');
                }
            }

            // Fetch and populate device balance if available
            function updateDeviceBalance() {
                // Skip auto-refresh if a device has been loaded - preserve loaded device data
                if (node.loadedDeviceFilename) {
                    console.log(`[BUYER AUTO-REFRESH] Skipping balance update - device loaded: ${node.loadedDeviceFilename}`);
                    return;
                }
                
                if (node.id) {
                    // First check if device file exists before making API calls
                    $.get(`/buyer/device-exists/${node.id}`)
                        .done(function (existsData) {
                            if (existsData.success && existsData.exists) {
                                // Device file exists, fetch balance
                                $.get(`/buyer/device-balance/${node.id}`)
                                    .done(function (data) {
                                        if (data.success && data.balance) {
                                            $('#node-input-balance').val(data.balance + ' USDC');
                                        } else {
                                            $('#node-input-balance').val('Not initialized yet');
                                        }
                                    })
                                    .fail(function () {
                                        $('#node-input-balance').val('Error loading balance');
                                    });
                            } else {
                                // Device file doesn't exist, show new node message
                                $('#node-input-balance').val('New node - balance will be available after deployment');
                            }
                        })
                        .fail(function () {
                            // If device-exists check fails, assume new node
                            $('#node-input-balance').val('New node - balance will be available after deployment');
                        });
                } else {
                    $('#node-input-balance').val('New node - balance will be available after deployment');
                }
            }

            // Check if device exists and show/hide runtime information section
            function checkDeviceExistsAndShowRuntime() {
                // If a device has been loaded from dropdown, show runtime information section
                if (node.loadedDeviceFilename) {
                    console.log(`[DEVICE EXISTS] Device loaded from dropdown: ${node.loadedDeviceFilename}, showing runtime information`);
                    $('#runtime-information-section').show();
                    $('#no-device-message').hide();
                    return;
                }
                
                if (node.id) {
                    console.log(`[DEVICE EXISTS] Checking device file for node ID: ${node.id}`);
                    $.get(`/buyer/device-exists/${node.id}`)
                        .done(function (data) {
                            console.log(`[DEVICE EXISTS] Response for ${node.id}:`, data);

                            if (data.success && data.exists) {
                                // Device file exists, show runtime information section and hide message
                                $('#runtime-information-section').show();
                                $('#no-device-message').hide();
                                console.log(`[DEVICE EXISTS] Device file found, showing runtime information`);
                            } else {
                                // Device file doesn't exist, hide runtime information section and show message
                                $('#runtime-information-section').hide();
                                $('#no-device-message').show();
                                console.log(`[DEVICE EXISTS] Device file not found, hiding runtime information`);
                            }
                        })
                        .fail(function (xhr, status, error) {
                            console.error(`[DEVICE EXISTS] Failed to check device file for ${node.id}:`, error);
                            // On error, hide the runtime section and show message
                            $('#runtime-information-section').hide();
                            $('#no-device-message').show();
                        });
                } else {
                    // No node ID available, hide runtime information section and show message
                    $('#runtime-information-section').hide();
                    $('#no-device-message').show();
                    console.log(`[DEVICE EXISTS] No node ID available, hiding runtime information`);
                }
            }

            checkDeviceExistsAndShowRuntime();

            // Make configuration fields readonly if node has been deployed
            makeFieldsReadonlyIfDeployed();

            // Update EVM address and public key ONCE on dialog open (only if no device is loaded)
            if (!node.loadedDeviceFilename) {
                updateEvmAddressAndPublicKeyAndTopics();
            } else {
                console.log(`[BUYER INIT] Skipping EVM update - device already loaded: ${node.loadedDeviceFilename}`);
            }

            // Update balance ONCE on dialog open (only if no device is loaded)
            if (!node.loadedDeviceFilename) {
                updateDeviceBalance();
            } else {
                console.log(`[BUYER INIT] Skipping balance update - device already loaded: ${node.loadedDeviceFilename}`);
            }

            // Load heartbeat ONCE on dialog open (always load, regardless of device loading status)
            loadHeartbeat();
            // Load reachability ONCE on dialog open (always load, regardless of device loading status)
            loadReachability();
        },


        oneditcancel: function () {
            // Clean up intervals when dialog is cancelled/closed
            if (this._cleanup) {
                this._cleanup();
            }
        },

        oneditsave: function () {
            // Clean up intervals when dialog is saved/closed
            if (this._cleanup) {
                this._cleanup();
            }

            // Save devices in new format
            this.sellerEvmAddress = this.devicesList.map(d => d.evmAddress);
            this.sellerDevices = this.devicesList; // Store full device objects

            // Save the current runtime information
            this.evmAddress = $('#node-input-evmAddress').val();
            this.balance = $('#node-input-balance').val();
            this.publicKey = $('#node-input-publicKey').val();
            // Save the new topic fields
            this.stdInTopic = $('#node-input-stdInTopic').val();
            this.stdOutTopic = $('#node-input-stdOutTopic').val();
            this.stdErrTopic = $('#node-input-stdErrTopic').val();
            // Save the heartbeat field
            this.heartbeat = $('#node-input-heartbeat').val();
            // Save the reachability field
            this.reachability = $('#node-input-reachability').val();
        }
    });

    // Connection status initialization function
    function initializeBuyerConnectionStatus(nodeId) {
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const refreshBtn = document.getElementById('refresh-connections-btn');
        // const peersLoading = document.getElementById('peers-loading');
        //const peersContent = document.getElementById('peers-content');
        //const connectedCount = document.getElementById('connected-count');
        //const totalCount = document.getElementById('total-count');
        //const noPeersMessage = document.getElementById('no-peers-message');
        //const peersTable = document.getElementById('peers-table');
        // const peersTableBody = document.getElementById('peers-table-body');
        //const lastUpdateTime = document.getElementById('last-update-time');

        let isRefreshing = false;

        function updateStatusIndicator(status) {
            // Remove all status classes
            statusDot.classList.remove('connection-status-connected', 'connection-status-disconnected', 'connection-status-connecting', 'connection-status-unknown');

            if (status.isConnected) {
                if (status.connectedPeers > 0) {
                    statusDot.classList.add('connection-status-connected');
                } else {
                    statusDot.classList.add('connection-status-connecting');
                }
                statusText.textContent = `Connected (${status.connectedPeers}/${status.totalPeers} peers)`;

            } else if (status.reconnectAttempts > 0) {
                statusDot.classList.add('connection-status-connecting');
                statusText.textContent = `Connecting... (${status.reconnectAttempts} attempts)`;
            } else {
                statusDot.classList.add('connection-status-disconnected');
                statusText.textContent = 'Disconnected';
            }
        }

        /*  function updatePeersDisplay(status) {
              const peers = status.peers || [];
              const connectedPeers = peers.filter(p => p.connectionStatus === 'connected');
              
              // Update summary
              connectedCount.textContent = connectedPeers.length;
              totalCount.textContent = peers.length;
              
              // Show/hide content
              peersLoading.style.display = 'none';
              peersContent.style.display = 'block';
              
              if (peers.length === 0) {
                  noPeersMessage.style.display = 'block';
                  peersTable.style.display = 'none';
              } else {
                  noPeersMessage.style.display = 'none';
                  peersTable.style.display = 'table';
                  
                  // Clear existing rows
                  peersTableBody.innerHTML = '';
                  
                  // Add peer rows
                  peers.forEach(peer => {
                      const row = document.createElement('tr');
                      row.className = 'peers-table-row';
                      
                      const publicKeyCell = document.createElement('td');
                      publicKeyCell.className = 'peers-table-cell peer-public-key';
                      publicKeyCell.textContent = peer.publicKey || 'Unknown';
                      publicKeyCell.title = peer.publicKey || 'Unknown';
                      
                      const statusCell = document.createElement('td');
                      statusCell.className = 'peers-table-cell';
                      statusCell.style.textAlign = 'center';
                      const statusSpan = document.createElement('span');
                      statusSpan.textContent = peer.connectionStatus || 'unknown';
                      statusSpan.className = `peer-status-${peer.connectionStatus || 'unknown'}`;
                      statusCell.appendChild(statusSpan);
                      
                      const lastUpdateCell = document.createElement('td');
                      lastUpdateCell.className = 'peers-table-cell';
                      lastUpdateCell.style.textAlign = 'center';
                      lastUpdateCell.textContent = peer.lastUpdate ? new Date(peer.lastUpdate).toLocaleTimeString() : 'N/A';
                      
                      row.appendChild(publicKeyCell);
                      row.appendChild(statusCell);
                      row.appendChild(lastUpdateCell);
                      peersTableBody.appendChild(row);
                  });
              }
              
              // Update last update time
              if (status.lastUpdate) {
                  lastUpdateTime.textContent = new Date(status.lastUpdate).toLocaleString();
              } else {
                  lastUpdateTime.textContent = 'Never';
              }
          }*/

        async function loadConnectionStatus() {
            try {
                const response = await fetch(`/buyer/connection-status/${nodeId}`);
                if (response.ok) {
                    const status = await response.json();
                    updateStatusIndicator(status);
                    //updatePeersDisplay(status);
                } else {
                    //console.error('Failed to load connection status:', response.statusText);
                    statusText.textContent = 'Error loading status';
                    statusDot.classList.add('connection-status-unknown');
                }
            } catch (error) {
                console.error('Error loading connection status:', error);
                statusText.textContent = 'Error loading status';
                statusDot.classList.add('connection-status-unknown');
            }
        }

        /*async function refreshConnections() {
            if (isRefreshing) return;
            
           // console.log('[DEBUG] Starting refresh connections...');
            isRefreshing = true;
            
            // Get button element directly and show spinner immediately
            const btn = document.getElementById('refresh-connections-btn');
            if (btn) {
               // console.log('[DEBUG] Button found, showing spinner');
                btn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Refreshing...';
                btn.style.opacity = '0.6';
                btn.disabled = true;
            } else {
                console.log('[DEBUG] Button NOT found');
            }
            
            try {
                // Add delay so you can see the spinner
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const response = await fetch(`/buyer/refresh-connections/${nodeId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    updateStatusIndicator(result.status);
                    //updatePeersDisplay(result.status);
                   // console.log('[DEBUG] Refresh completed successfully');
                } else {
                    console.error('Failed to refresh connections:', response.statusText);
                }
            } catch (error) {
                console.error('Error refreshing connections:', error);
            } finally {
                // Restore button
                const btn = document.getElementById('refresh-connections-btn');
                if (btn) {
                    btn.innerHTML = '<i class="fa fa-refresh"></i> Refresh';
                    btn.style.opacity = '1';
                    btn.disabled = false;
                   // console.log('[DEBUG] Button restored');
                }
                isRefreshing = false;
               // console.log('[DEBUG] Refresh process completed');
            }
        }*/

        // Set up event listeners
        // refreshBtn.addEventListener('click', refreshConnections);

        // Load initial status (single call only)
        /* loadConnectionStatus();
 
         // Remove the periodic refresh - no more polling
         // const statusInterval = setInterval(loadConnectionStatus, 30000);
 
         // Cleanup function (no interval to clear)
         return () => {
             refreshBtn.removeEventListener('click', refreshConnections);
         };
         */
    }

    // Function to fetch and display last seen data
    async function fetchLastSeen(device, index) {
        try {
            // Much simpler - just need the topic ID
            const response = await fetch(`/buyer/last-seen/${device.stdOutTopic}`);
            const data = await response.json();

            const lastSeenCell = $(`#lastseen-cell-${index}`);

            if (data.success) {
                if (data.lastSeen !== null) {
                    // Color code based on how recent the activity is
                    let color = '#888'; // default gray
                    if (data.lastSeen < 300) { // less than 5 minutes
                        color = '#28a745'; // green
                    } else if (data.lastSeen < 3600) { // less than 1 hour
                        color = '#ffc107'; // yellow
                    } else if (data.lastSeen < 86400) { // less than 1 day
                        color = '#fd7e14'; // orange
                    } else {
                        color = '#dc3545'; // red
                    }

                    lastSeenCell.html(`<span style="color: ${color};">${data.lastSeenFormatted}</span>`);
                } else {
                    lastSeenCell.html('<span style="color: #888;">Never</span>');
                }
            } else {
                lastSeenCell.html('<span style="color: #dc3545;"></span>');
            }
        } catch (error) {
            console.error(`Error fetching last seen for device ${index}:`, error);
            $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
        }
    }

    // Function to update all device statuses and last seen - INSIDE oneditprepare
    async function updateAllDeviceStatuses() {
        // console.log('[DEBUG] === Starting updateAllDeviceStatuses ===');
        //  console.log('[DEBUG] node.id:', node.id);
        // console.log('[DEBUG] devicesList length:', node.devicesList.length);

        if (!node.id) {
            // console.log('[DEBUG] No node.id available');
            node.devicesList.forEach((device, index) => {
                $(`#status-cell-${index}`).html('<span style="color: #dc3545;">No Node ID</span>');
                $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">No Node ID</span>');
            });
            return;
        }

        try {
            // Get connection status
            // console.log('[DEBUG] Fetching connection status...');
            const connectionResponse = await fetch(`/buyer/connection-status/${node.id}`);

            if (!connectionResponse.ok) {
                throw new Error(`Connection API returned ${connectionResponse.status}`);
            }

            const connectionData = await connectionResponse.json();
            // console.log('[DEBUG] Connection data:', connectionData);

            // Create status map
            const statusMap = new Map();
            if (connectionData.data && Array.isArray(connectionData.data)) {
                connectionData.data.forEach(peer => {
                    if (peer.publicKey) {
                        statusMap.set(peer.publicKey, peer.connectionStatus || 'Not connected');
                    }
                });
            }

            // console.log('[DEBUG] Status map has', statusMap.size, 'entries');

            // Update each device
            for (let index = 0; index < node.devicesList.length; index++) {
                const device = node.devicesList[index];
                // console.log('[DEBUG] Processing device', index, ':', device.evmAddress);

                // Update status
                updateDeviceStatus(device, index, statusMap);

                // Update last seen
                updateLastSeen(device, index);
            }

            // console.log('[DEBUG] All devices processed');

        } catch (error) {
            // console.error('[DEBUG] Error in updateAllDeviceStatuses:', error);
            node.devicesList.forEach((device, index) => {
                $(`#status-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
                $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
            });
        }
    }

    // Function to update device status - INSIDE oneditprepare
    async function updateDeviceStatus(device, index, statusMap) {
        try {
            // console.log('[DEBUG] Getting public key for:', device.evmAddress);

            const evmResponse = await fetch(`/buyer/evm-to-publickey/${device.evmAddress}`);
            const evmData = await evmResponse.json();

            const statusCell = $(`#status-cell-${index}`);

            if (evmData.success) {
                const publicKey = evmData.publicKey;
                const connectionStatus = statusMap.get(publicKey) || 'Disconnected';

                // console.log('[DEBUG] Device', index, 'PublicKey:', publicKey, 'Status:', connectionStatus);

                let color = '#dc3545'; // red
                if (connectionStatus === 'Connected') {
                    color = '#28a745'; // green
                } else if (connectionStatus === 'Connecting') {
                    color = '#ffc107'; // yellow
                }

                statusCell.html(`<span style="color: ${color};">${connectionStatus}</span>`);
            } else {
                // console.log('[DEBUG] Failed to get public key for device', index);
                statusCell.html('<span style="color: #dc3545;">Key Error</span>');
            }
        } catch (error) {
            //  console.error('[DEBUG] Error updating status for device', index, ':', error);
            $(`#status-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
        }
    }

    // Function to update last seen - INSIDE oneditprepare
    async function updateLastSeen(device, index) {
        try {
            if (!device.stdOutTopic || device.stdOutTopic === 'Unknown') {
                $(`#lastseen-cell-${index}`).html('<span style="color: #888;">No Topic</span>');
                return;
            }

            // console.log('[DEBUG] Getting last seen for topic:', device.stdOutTopic);

            const normalizedTopic = normalizeTopicFormat(device.stdOutTopic);
            const response = await fetch(`/buyer/last-seen/${normalizedTopic}`);
            const data = await response.json();

            const lastSeenCell = $(`#lastseen-cell-${index}`);

            if (data.success) {
                if (data.lastSeen !== null) {
                    let color = '#888';
                    if (data.lastSeen < 300) color = '#28a745';
                    else if (data.lastSeen < 3600) color = '#ffc107';
                    else if (data.lastSeen < 86400) color = '#fd7e14';
                    else color = '#dc3545';

                    lastSeenCell.html(`<span style="color: ${color};">${data.lastSeenFormatted}</span>`);
                } else {
                    lastSeenCell.html('<span style="color: #888;">Never</span>');
                }
            } else {
                lastSeenCell.html('<span style="color: #dc3545;">API Error</span>');
            }
        } catch (error) {
            // console.error('[DEBUG] Error updating last seen for device', index, ':', error);
            $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
        }
    }

    // Function to handle peers that are connected but not in our device list
    async function handleAdditionalPeers(peersData, statusMap) {
        if (!peersData || !Array.isArray(peersData)) return;

        const tableBody = $('#devices-table-body');
        const existingPublicKeys = new Set();

        // Collect public keys from existing rows
        tableBody.find('tr').each(function () {
            const publicKey = $(this).data('publicKey');
            if (publicKey) {
                existingPublicKeys.add(publicKey);
            }
        });

        // Add rows for peers not in our device list
        peersData.forEach((peer, peerIndex) => {
            if (peer.publicKey && !existingPublicKeys.has(peer.publicKey)) {
                const newIndex = node.devicesList.length + peerIndex;
                const row = $(`
                    <tr data-publickey="${peer.publicKey}" data-index="additional-${peerIndex}" style="background-color: #f8f9fa;">
                        <td style="padding: 8px; border: 1px solid #555; font-family: monospace; font-size: 11px; color: #888;">
                            Unknown EVM
                        </td>
                        <td style="padding: 8px; border: 1px solid #555; color: #888;">-</td>
                        <td style="padding: 8px; border: 1px solid #555; color: #888;">-</td>
                        <td style="padding: 8px; border: 1px solid #555; color: #888;">-</td>
                        <td style="padding: 8px; border: 1px solid #555; text-align: center; font-size: 11px;">
                            <span style="color: #28a745;">${peer.connectionStatus || 'Connected'}</span>
                        </td>
                        <td style="padding: 8px; border: 1px solid #555; text-align: center; color: #888;">-</td>
                        <td style="padding: 8px; border: 1px solid #555; text-align: center;">
                            <span style="color: #888; font-size: 10px;">External</span>
                        </td>
                    </tr>
                `);
                tableBody.append(row);
            }
        });
    }

    // Helper to normalize Hedera topic format to 0.0.xxxxxxx
    function normalizeTopicFormat(topic) {
        if (typeof topic !== 'string') return topic;
        if (/^0\.0\.\d+$/.test(topic)) return topic;
        if (/^0\.0\d+$/.test(topic)) return topic.replace(/^0\.0(\d+)$/, '0.0.$1');
        if (/^\d+$/.test(topic)) return `0.0.${topic}`;
        return topic;
    }
</script>

<style>
    .neuron-buyer-config .form-row {
        display: flex;
        margin-bottom: 8px;
        align-items: center;
        min-width: 430px;
    }

    .neuron-buyer-config #devices-table-container {
        padding: 8px;
        width: 100%;
        box-sizing: border-box;
        overflow-x: auto;
        min-width: 430px;
    }

    .neuron-buyer-config #devices-table {
        table-layout: auto;
        width: 100%;
    }

    .neuron-buyer-config #devices-table th {
        background-color: #2d2d2d !important;
        color: white !important;
        padding: 4px 6px;
    }

    .neuron-buyer-config #devices-table td {
        background-color: #3c3c3c;
        color: white;
        padding: 4px 6px;
    }

    .neuron-buyer-config #devices-table tbody tr:hover {
        background-color: #4a4a4a;
    }

    .neuron-buyer-config #evm-address-input {
        border: 1px solid #ccc;
        border-radius: 3px;
        padding: 6px 8px;
    }

    .neuron-buyer-config #evm-address-input:focus {
        border-color: #4d90fe;
        outline: none;
        box-shadow: 0 0 3px rgba(77, 144, 254, 0.3);
    }

    .neuron-buyer-config .remove-device-btn {
        background-color: #ff6b6b !important;
        border-color: #ff6b6b !important;
    }

    .neuron-buyer-config .remove-device-btn:hover {
        background-color: #ff5252 !important;
        border-color: #ff5252 !important;
    }

    .neuron-buyer-config .connection-status-connected {
        background-color: #4CAF50 !important;
    }

    .neuron-buyer-config .connection-status-disconnected {
        background-color: #f44336 !important;
    }

    .neuron-buyer-config .connection-status-connecting {
        background-color: #ff9800 !important;
    }

    .neuron-buyer-config .connection-status-unknown {
        background-color: #9e9e9e !important;
    }

    @keyframes fa-spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .neuron-buyer-config .fa-spin {
        animation: fa-spin 1s infinite linear !important;
    }

    .neuron-buyer-config #devices-summary {
        padding-top: 8px;
        margin-top: 8px;
        font-size: 12px;
    }

    .neuron-buyer-config #no-device-message {
        background-color: #f8f9fa !important;
        border: 1px solid #dee2e6 !important;
        color: #6c757d !important;
    }

    @media (prefers-color-scheme: dark) {
        .neuron-buyer-config #no-device-message {
            background-color: #2d2d2d !important;
            border-color: #555 !important;
            color: #adb5bd !important;
        }
    }
</style>


<script type="text/x-red" data-help-name="buyer config">
    <p>A configuration node that creates and manages a buyer device in the Neuron network with Hedera blockchain integration.</p>
    
    <h3>Overview</h3>
    <p>The Buyer Node is a configuration node that allows you to specify device details for a buyer device. When deployed, it automatically:</p>
    <ul>
        <li>Creates a Hedera account for the device</li>
        <li>Creates 3 Hedera topics for communication</li>
        <li>Registers the device to the specified smart contract</li>
        <li>Spawns the Neuron SDK process</li>
    </ul>
    
    <h3>Outputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">object</span></dt>
        <dd>Contains the device configuration and connection details</dd>
        <dt>payload.deviceInfo <span class="property-type">object</span></dt>
        <dd>The complete device credentials and account details created by Hedera</dd>
        <dt>payload.connection <span class="property-type">string</span></dt>
        <dd>Status message indicating connection to the Neuron network</dd>
    </dl>
    
    <h3>Configuration</h3>
    <ul>
        <li><b>Name</b>: A unique identifier for this buyer node</li>
        <li><b>Smart Contract</b>: The target smart contract to register with (JetVision Demo, P2P Chat Demo, or Developer Open Challenges)</li>
        <li><b>Device Type</b>: Type of device (e.g., Cloud, Edge)</li>
        <li><b>Seller EVM Addresses</b>: Select which seller devices this buyer can interact with</li>
        <li><b>Description</b>: Optional description for the device</li>
    </ul>
    
    <h3>Runtime Information</h3>
    <p>After successful deployment, the node displays:</p>
    <ul>
        <li><b>EVM Address</b>: The Ethereum Virtual Machine address of the created account</li>
        <li><b>Balance</b>: Current HBAR balance of the device account</li>
        <li><b>Connection Status</b>: Real-time connection status to the Neuron network</li>
        <li><b>Connected Peers</b>: List of currently connected seller nodes</li>
    </ul>
    
    <h3>Device Credentials Output</h3>
    <p>The node outputs complete Hedera account details including:</p>
    <ul>
        <li>Account ID and private key</li>
        <li>Three Hedera topic IDs for communication</li>
        <li>Smart contract address</li>
        <li>Device metadata (name, type, serial number)</li>
        <li>Public key for peer-to-peer communication</li>
    </ul>
    
    <h3>Network Communication</h3>
    <p>To listen and write to the Neuron network after deployment:</p>
    <ul>
        <li>Use the <b>Neuron P2P</b> node for peer-to-peer communication</li>
        <li>The buyer node automatically spawns the Neuron SDK process</li>
        <li>WebSocket connections are established for real-time messaging</li>
        <li><b>Port Configuration</b>: Ensure ports 61336-61346 are forwarded on your router/firewall</li>
        <li><b>Network Access</b>: Other devices need to reach these ports for P2P connectivity</li>
    </ul>
    
    <h3>Status Indicators</h3>
    <ul>
        <li><span style="color:blue">●</span> Creating new device: Initial setup in progress</li>
        <li><span style="color:green">●</span> Process spawned: Neuron SDK process is running</li>
        <li><span style="color:yellow">●</span> Loading device info: Reading persisted device data</li>
        <li><span style="color:red">●</span> Error states: Configuration error, account creation failed, etc.</li>
    </ul>
    
    <h3>Prerequisites</h3>
    <ul>
        <li>Valid Hedera credentials must be configured</li>
        <li>Selected smart contract must be deployed and accessible</li>
        <li>Network connectivity for Hedera testnet/mainnet</li>
        <li><b>Port Forwarding</b>: Ports 61336 to 61346 must be forwarded for proper network communication</li>
    </ul>
    
    <h3>Network Setup</h3>
    <p>For the buyer node to communicate with other devices in the Neuron network:</p>
    <ul>
        <li><b>Port Range</b>: Forward ports 61336 to 61346 (inclusive) on your router</li>
        <li><b>Protocol</b>: Both TCP and UDP should be forwarded for these ports</li>
        <li><b>Target</b>: Forward to the IP address of the machine running Node-RED</li>
        <li><b>Firewall</b>: Ensure local firewall allows incoming connections on these ports</li>
        <li><b>Testing</b>: Use port scanning tools to verify ports are accessible externally</li>
    </ul>
    
    <h3>Usage Notes</h3>
    <ul>
        <li>Device information is automatically persisted and reloaded on restart</li>
        <li>The node can be deployed multiple times safely - existing devices are reused</li>
        <li>Monitor the connection status to ensure proper network connectivity</li>
        <li>Use refresh button to update peer connection information</li>
    </ul>
</script>